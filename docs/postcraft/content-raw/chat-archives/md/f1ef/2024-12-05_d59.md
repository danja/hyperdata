# [Enabling Processor-to-Processor Communication](https://claude.ai/chat/f1efec51-cda9-4c64-801f-fbd06bf8d4ed)

d5956fd6-629d-4b1d-8f6e-89871833731f

 Here's how processors would interact with the event bus:

<antArtifact identifier="processor-bus-usage" type="application/vnd.ant.code" language="javascript" title="Processor Event Bus Integration">
class BusEnabledProcessor extends Processor {
  constructor(config) {
    super(config);
    // Events this processor handles
    this.subscriptions = {
      'data.available': this.handleData.bind(this),
      'process.request': this.handleRequest.bind(this)
    };
  }

  // Called when processor registered with transmission
  onRegistered() {
    const bus = this.transmission.eventBus;
    
    // Subscribe to events
    Object.entries(this.subscriptions).forEach(([event, handler]) => {
      bus.subscribe(this.id, event, handler);
    });
  }

  async process(message) {
    // Normal processing
    const result = await this.doProcess(message);
    
    // Publish result on bus
    this.transmission.eventBus.publish(
      'process.complete', 
      { 
        result,
        processorId: this.id 
      },
      this.id
    );
  }

  // Handle incoming data event
  async handleData(message) {
    const { data, metadata } = message;
    // Process data...
    this.emit('message', { data, metadata });
  }

  // Request handler
  async handleRequest(message) {
    const { requestId, params } = message;
    try {
      const result = await this.processRequest(params);
      // Reply on bus
      this.transmission.eventBus.publish(
        'process.response',
        { requestId, result },
        this.id  
      );
    } catch(error) {
      this.transmission.eventBus.publish(
        'process.error',
        { requestId, error },
        this.id
      );
    }
  }
}

// Example usage in concrete processor
class DataTransformer extends BusEnabledProcessor {
  constructor(config) {
    super(config);
    // Add specific subscriptions
    this.subscriptions['data.transform'] = this.transform.bind(this);
  }

  async transform(message) {
    const transformed = doTransform(message.data);
    this.transmission.eventBus.publish(
      'data.transformed',
      transformed,
      this.id
    );
  }
}
</antArtifact>

Key points:
1. Processors declare subscriptions 
2. Event handlers bound to processor instance
3. Self-identifying in messages via processor.id
4. Pattern matches for routing (e.g. 'data.*')

q1: Should we add message schemas for type safety?

q2: Would you like to see a request-reply pattern implementation?

q3: Would message serialization help with debugging?

q4: Should we add message correlation IDs for tracking flows?

---

* **sourceFile** : /home/danny/github-danny/hyperdata/docs/chat-archives/data-2025-01-25-12-45-58/conversations.json
* **appName** : claude-json-converter
* **appPath** : claude-json-converter
* **subtask** : [undefined]
* **rootDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter
* **dataDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **targetPath** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **tags** : ccc10.ccc20.ccc30.ccc40.ccc50
* **done** : [undefined]
* **meta** : {
  "conv_uuid": "f1efec51-cda9-4c64-801f-fbd06bf8d4ed",
  "conv_name": "Enabling Processor-to-Processor Communication",
  "updated_at": "2024-12-05T06:37:07.328095Z"
}
* **filepath** : /home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md/f1ef/2024-12-05_d59.md