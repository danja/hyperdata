# [Flexible JSON Array Sorting Processor](https://claude.ai/chat/811a8eb8-acd3-4b87-98b8-5bd35a3d4b6a)

ad27dcf7-27e3-454c-a97d-478c6f48f9d3

 I'll help extend the Sort processor and create the test infrastructure.



<antArtifact identifier="json-sort-processor-updated" type="application/vnd.ant.code" language="javascript" title="Updated Sort Processor with Custom Comparator">
import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'
import ns from '../../utils/ns.js'

class Sort extends Processor {
    constructor(config) {
        super(config)
        this.defaultTarget = 'content'
        this.defaultRule = {
            key: null,
            direction: 'asc'
        }
        this.comparators = {
            // Example built-in custom comparator for version strings
            version: (a, b) => {
                const partsA = a.split('.')
                const partsB = b.split('.')
                for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
                    const numA = parseInt(partsA[i] || 0)
                    const numB = parseInt(partsB[i] || 0)
                    if (numA !== numB) return numA - numB
                }
                return 0
            }
        }
    }

    async process(message) {
        try {
            const sortConfig = this.getSortConfig(message)
            let targetArray = this.getTargetArray(message, sortConfig.target)
            
            if (!Array.isArray(targetArray)) {
                throw new Error(`Target '${sortConfig.target}' is not an array`)
            }

            const sortedArray = this.sortArray(targetArray, sortConfig.rule)
            this.updateTarget(message, sortConfig.target, sortedArray)

            return this.emit('message', message)
        } catch (error) {
            logger.error(`Sort processor error: ${error.message}`)
            throw error
        }
    }

    getSortConfig(message) {
        if (message.sort?.target && message.sort?.rule) {
            return {
                target: message.sort.target,
                rule: message.sort.rule
            }
        }

        if (this.configKey) {
            const configTarget = this.getPropertyFromMyConfig(ns.trm.target)
            const configRule = this.getPropertyFromMyConfig(ns.trm.rule)
            if (configTarget && configRule) {
                return {
                    target: configTarget.value,
                    rule: JSON.parse(configRule.value)
                }
            }
        }

        return {
            target: this.defaultTarget,
            rule: this.defaultRule
        }
    }

    getTargetArray(message, target) {
        return target.split('.').reduce((obj, key) => obj[key], message)
    }

    updateTarget(message, target, sortedArray) {
        const parts = target.split('.')
        const last = parts.pop()
        const parent = parts.reduce((obj, key) => obj[key], message)
        parent[last] = sortedArray
    }

    sortArray(array, rule) {
        return [...array].sort((a, b) => {
            let valueA, valueB

            if (rule.key === null) {
                valueA = a
                valueB = b
            } else {
                valueA = this.getNestedValue(a, rule.key)
                valueB = this.getNestedValue(b, rule.key)
            }

            // Use custom comparator if specified
            if (rule.comparator) {
                if (typeof rule.comparator === 'function') {
                    return rule.comparator(valueA, valueB)
                } else if (this.comparators[rule.comparator]) {
                    return this.comparators[rule.comparator](valueA, valueB)
                } else {
                    throw new Error(`Unknown comparator: ${rule.comparator}`)
                }
            }

            // Default comparison logic
            if (valueA instanceof Date) {
                valueA = valueA.getTime()
                valueB = valueB.getTime()
            } else if (typeof valueA === 'string') {
                valueA = valueA.toLowerCase()
                valueB = valueB.toLowerCase()
            }

            const direction = rule.direction === 'desc' ? -1 : 1
            if (valueA < valueB) return -1 * direction
            if (valueA > valueB) return 1 * direction
            return 0
        })
    }

    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) => {
            if (current === null || current === undefined) {
                return current
            }
            let value = current[key]
            if (typeof value === 'string' && Date.parse(value)) {
                value = new Date(value)
            }
            return value
        }, obj)
    }

    registerComparator(name, comparatorFn) {
        this.comparators[name] = comparatorFn
    }
}

export default Sort
</antArtifact>

<antArtifact identifier="sort-unit-test" type="application/vnd.ant.code" language="javascript" title="Unit Tests for Sort Processor">
import Sort from '../../processors/json/Sort.js'
import { expect } from 'chai'

describe('Sort Processor', () => {
    let sortProcessor

    beforeEach(() => {
        sortProcessor = new Sort({})
    })

    it('should sort simple arrays with default settings', async () => {
        const message = {
            content: [3, 1, 4, 1, 5]
        }
        
        await sortProcessor.process(message)
        expect(message.content).to.deep.equal([1, 1, 3, 4, 5])
    })

    it('should sort arrays by object property', async () => {
        const message = {
            content: [
                { name: 'Charlie' },
                { name: 'Alice' },
                { name: 'Bob' }
            ],
            sort: {
                target: 'content',
                rule: {
                    key: 'name'
                }
            }
        }
        
        await sortProcessor.process(message)
        expect(message.content.map(item => item.name))
            .to.deep.equal(['Alice', 'Bob', 'Charlie'])
    })

    it('should sort by nested properties', async () => {
        const message = {
            files: [
                { metadata: { size: 200 } },
                { metadata: { size: 100 } },
                { metadata: { size: 300 } }
            ],
            sort: {
                target: 'files',
                rule: {
                    key: 'metadata.size'
                }
            }
        }
        
        await sortProcessor.process(message)
        expect(message.files.map(f => f.metadata.size))
            .to.deep.equal([100, 200, 300])
    })

    it('should sort using custom comparator', async () => {
        sortProcessor.registerComparator('reverseString', (a, b) => 
            b.localeCompare(a))

        const message = {
            content: ['cat', 'dog', 'bird'],
            sort: {
                target: 'content',
                rule: {
                    comparator: 'reverseString'
                }
            }
        }
        
        await sortProcessor.process(message)
        expect(message.content).to.deep.equal(['dog', 'cat', 'bird'])
    })

    it('should sort dates correctly', async () => {
        const message = {
            content: [
                { date: '2023-01-01' },
                { date: '2024-01-01' },
                { date: '2022-12-31' }
            ],
            sort: {
                target: 'content',
                rule: {
                    key: 'date',
                    direction: 'desc'
                }
            }
        }
        
        await sortProcessor.process(message)
        expect(message.content[0].date).to.equal('2024-01-01')
        expect(message.content[2].date).to.equal('2022-12-31')
    })

    it('should handle invalid targets gracefully', async () => {
        const message = {
            content: "not an array",
            sort: {
                target: 'content',
                rule: { key: null }
            }
        }
        
        try {
            await sortProcessor.process(message)
            expect.fail('Should have thrown error')
        } catch (error) {
            expect(error.message).to.include('not an array')
        }
    })
})
</antArtifact>

<antArtifact identifier="test-sort-application" type="application/vnd.ant.code" language="javascript" title="Test Sort Application Files">
// File: src/applications/test_sort/data/input/input-01.json
{
    "files": [
        {
            "name": "document.txt",
            "metadata": {
                "lastModified": "2024-03-15T10:30:00Z",
                "size": 1500
            }
        },
        {
            "name": "image.jpg",
            "metadata": {
                "lastModified": "2024-03-16T15:45:00Z",
                "size": 2500
            }
        },
        {
            "name": "archive.zip",
            "metadata": {
                "lastModified": "2024-03-14T08:15:00Z",
                "size": 5000
            }
        }
    ]
}

// File: src/applications/test_sort/data/output/required-01.json
{
    "files": [
        {
            "name": "image.jpg",
            "metadata": {
                "lastModified": "2024-03-16T15:45:00Z",
                "size": 2500
            }
        },
        {
            "name": "document.txt",
            "metadata": {
                "lastModified": "2024-03-15T10:30:00Z",
                "size": 1500
            }
        },
        {
            "name": "archive.zip",
            "metadata": {
                "lastModified": "2024-03-14T08:15:00Z",
                "size": 5000
            }
        }
    ]
}
</antArtifact>

<antArtifact identifier="test-sort-config" type="application/vnd.ant.code" language="turtle" title="Test Sort Configuration Files">
# File: src/applications/test_sort/config.ttl
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix t: <http://hyperdata.it/transmissions/> .

t:SortConfig a trm:ServiceConfig ;
    trm:configKey t:sort ;
    trm:target "files" ;
    trm:rule """{"key": "metadata.lastModified", "direction": "desc"}""" .

# File: src/applications/test_sort/transmissions.ttl
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix : <http://hyperdata.it/transmissions/> .

:test_sort a trm:Transmission ;
    trm:pipe (:read :sort :write) .

:read a :FileReader ;
    trm:configKey :reader ;
    trm:sourceFile "input/input-01.json" ;
    trm:mediaType "application/json" .

:sort a :Sort ;
    trm:configKey :sort .

:write a :FileWriter ;
    trm:configKey :writer ;
    trm:destinationFile "output/output-01.json" .
</antArtifact>

<antArtifact identifier="test-sort-simple" type="application/vnd.ant.code" language="javascript" title="Simple Test Sort Implementation">
import FileReader from '../../processors/fs/FileReader.js'
import Sort from '../../processors/json/Sort.js'
import FileWriter from '../../processors/fs/FileWriter.js'

const config = {
    "simples": "true",
    "sourceFile": "input/input-01.json",
    "destinationFile": "output/output-01.json",
    "mediaType": "application/json",
    "target": "files",
    "rule": {
        "key": "metadata.lastModified",
        "direction": "desc"
    }
}

async function runSimple() {
    var message = { "dataDir": "src/applications/test_sort/data" }

    const read = new FileReader(config)
    message = await read.process(message)

    const sort = new Sort(config)
    message = await sort.process(message)

    const write = new FileWriter(config)
    await write.process(message)
}

runSimple().catch(console.error)
</antArtifact>

The updated Sort processor and test infrastructure provides:

1. Custom comparator support through:
   - Function-based comparators
   - Named built-in comparators 
   - Registration API for adding new comparators

2. Complete test suite with:
   - Unit tests covering core functionality
   - Integration test application
   - Simple direct implementation
   - Sample input/output data

3. Graceful error handling for:
   - Invalid targets
   - Unknown comparators
   - Malformed data

q1: Would you like examples of additional custom comparators?
q2: Should I add more complex test cases?
q3: Would you like to see integration tests for edge cases?
q4: Would you like to see the factory and registration code for Sort processor?

---

* **sourceFile** : /home/danny/github-danny/hyperdata/docs/chat-archives/data-2025-01-25-12-45-58/conversations.json
* **appName** : claude-json-converter
* **appPath** : claude-json-converter
* **subtask** : [undefined]
* **rootDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter
* **dataDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **targetPath** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **tags** : ccc10.ccc20.ccc30.ccc40.ccc50
* **done** : [undefined]
* **meta** : {
  "conv_uuid": "811a8eb8-acd3-4b87-98b8-5bd35a3d4b6a",
  "conv_name": "Flexible JSON Array Sorting Processor",
  "updated_at": "2024-12-02T00:06:26.447782Z"
}
* **filepath** : /home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md/811a/2024-12-02_ad2.md