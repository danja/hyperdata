# [Extending Event-Driven Processors to Support Streaming](https://claude.ai/chat/7352ddcc-bebe-4ba3-b94b-48f2e20746ab)

90b73ccf-2de9-49ae-8e50-d5e8ca71b9bd

 I'll first create example pipelines using these utilities, then create comprehensive tests.

<antArtifact identifier="streaming-pipeline-example" type="application/vnd.ant.code" language="javascript" title="StreamingPipelineExample.js">
import StreamingFileReader from '../processors/fs/StreamingFileReader.js';
import StreamMonitor from '../utils/StreamMonitor.js';
import StreamBufferManager from '../utils/StreamBufferManager.js';
import logger from '../utils/Logger.js';

class StreamingPipelineExample {
    constructor(config) {
        this.fileReader = new StreamingFileReader(config);
        
        this.monitor1 = new StreamMonitor({ 
            name: 'input-monitor',
            reportInterval: 2000 
        });
        
        this.bufferManager = new StreamBufferManager({
            maxBufferSize: 2 * 1024 * 1024, // 2MB
            highWaterMark: 1.6 * 1024 * 1024, // 1.6MB
            lowWaterMark: 512 * 1024 // 512KB
        });
        
        this.monitor2 = new StreamMonitor({ 
            name: 'output-monitor',
            reportInterval: 2000 
        });
    }

    async process(inputFile, outputFile) {
        return new Promise((resolve, reject) => {
            this.fileReader.process({ filepath: inputFile })
                .pipe(this.monitor1)
                .pipe(this.bufferManager)
                .pipe(this.monitor2)
                .on('finish', () => {
                    logger.info('Pipeline completed');
                    const metrics = {
                        input: this.monitor1.getMetrics(),
                        buffer: this.bufferManager.getMetrics(),
                        output: this.monitor2.getMetrics()
                    };
                    resolve(metrics);
                })
                .on('error', (error) => {
                    logger.error('Pipeline error:', error);
                    reject(error);
                });
        });
    }
}

export default StreamingPipelineExample;
</antArtifact>

<antArtifact identifier="streaming-pipeline-config" type="text/turtle" title="streaming-pipeline.ttl">
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix strm: <http://purl.org/stuff/transmission/streaming/> .
@prefix : <http://hyperdata.it/transmissions/> .

:streaming_example a trm:Transmission ;
    trm:pipe (:reader :monitor1 :buffer :monitor2 :writer) .

:reader a :StreamingFileReader ;
    trm:configKey :readerConfig ;
    strm:chunkSize "65536"^^xsd:integer .

:monitor1 a :StreamMonitor ;
    trm:name "input-monitor" ;
    strm:reportInterval "2000"^^xsd:integer .

:buffer a :StreamBufferManager ;
    strm:maxBufferSize "2097152"^^xsd:integer ;
    strm:highWaterMark "1677721"^^xsd:integer ;
    strm:lowWaterMark "524288"^^xsd:integer .

:monitor2 a :StreamMonitor ;
    trm:name "output-monitor" ;
    strm:reportInterval "2000"^^xsd:integer .

:writer a :StreamingFileWriter ;
    trm:configKey :writerConfig .
</antArtifact>

Now for the tests:

<antArtifact identifier="stream-processor-test" type="application/vnd.ant.code" language="javascript" title="StreamProcessor.spec.js">
import { expect } from 'chai';
import { Readable, Writable } from 'stream';
import StreamProcessor from '../../src/processors/base/StreamProcessor.js';

describe('StreamProcessor', () => {
    let processor;
    let inputData;
    let outputData;

    beforeEach(() => {
        processor = new StreamProcessor({ objectMode: true });
        inputData = ['test1', 'test2', 'test3'];
        outputData = [];
    });

    it('should initialize in non-streaming mode', () => {
        expect(processor.isStreaming).to.be.false;
    });

    it('should switch to streaming mode when initStream is called', () => {
        processor.initStream();
        expect(processor.isStreaming).to.be.true;
    });

    it('should process data in streaming mode', (done) => {
        const readable = Readable.from(inputData);
        const writable = new Writable({
            objectMode: true,
            write(chunk, encoding, callback) {
                outputData.push(chunk);
                callback();
            }
        });

        readable
            .pipe(processor.initStream())
            .pipe(writable)
            .on('finish', () => {
                expect(outputData).to.deep.equal(inputData);
                done();
            });
    });

    it('should handle errors in streaming mode', (done) => {
        processor.process = async () => {
            throw new Error('Test error');
        };

        processor.on('error', (err) => {
            expect(err.message).to.equal('Test error');
            done();
        });

        processor.initStream();
        processor.stream.write('test');
    });

    it('should cleanup resources on destroy', () => {
        processor.initStream();
        processor.destroy();
        expect(processor.isStreaming).to.be.false;
    });
});
</antArtifact>

<antArtifact identifier="stream-monitor-test" type="application/vnd.ant.code" language="javascript" title="StreamMonitor.spec.js">
import { expect } from 'chai';
import { Readable } from 'stream';
import StreamMonitor from '../../src/utils/StreamMonitor.js';

describe('StreamMonitor', () => {
    let monitor;
    const testData = Buffer.from('x'.repeat(1024)); // 1KB of data

    beforeEach(() => {
        monitor = new StreamMonitor({
            name: 'test-monitor',
            reportInterval: 100
        });
    });

    it('should track basic metrics', (done) => {
        const readable = Readable.from([testData, testData, testData]);

        readable
            .pipe(monitor)
            .on('finish', () => {
                const metrics = monitor.getMetrics();
                expect(metrics.bytesProcessed).to.equal(3072);
                expect(metrics.chunksProcessed).to.equal(3);
                expect(metrics.averageChunkSize).to.equal(1024);
                done();
            });
    });

    it('should calculate throughput correctly', (done) => {
        const readable = Readable.from([testData]);

        readable
            .pipe(monitor)
            .on('finish', () => {
                const metrics = monitor.getMetrics();
                expect(metrics.throughput).to.be.above(0);
                expect(metrics.instantThroughput).to.be.above(0);
                done();
            });
    });

    it('should detect backpressure events', (done) => {
        const slowWritable = new Writable({
            write(chunk, encoding, callback) {
                setTimeout(callback, 50);
            }
        });

        monitor
            .pipe(slowWritable)
            .on('finish', () => {
                const metrics = monitor.getMetrics();
                expect(metrics.backpressureEvents).to.be.above(0);
                done();
            });

        for (let i = 0; i < 10; i++) {
            monitor.write(testData);
        }
        monitor.end();
    });
});
</antArtifact>

<antArtifact identifier="stream-buffer-manager-test" type="application/vnd.ant.code" language="javascript" title="StreamBufferManager.spec.js">
import { expect } from 'chai';
import { Readable, Writable } from 'stream';
import StreamBufferManager from '../../src/utils/StreamBufferManager.js';

describe('StreamBufferManager', () => {
    let bufferManager;
    
    beforeEach(() => {
        bufferManager = new StreamBufferManager({
            maxBufferSize: 1024 * 1024, // 1MB
            highWaterMark: 819200, // 800KB
            lowWaterMark: 204800 // 200KB
        });
    });

    it('should respect buffer limits', (done) => {
        const largeData = Buffer.alloc(900 * 1024); // 900KB
        
        bufferManager.write(largeData, () => {
            const metrics = bufferManager.getMetrics();
            expect(metrics.currentBufferSize).to.be.below(bufferManager.maxBufferSize);
            expect(metrics.pauseCount).to.be.above(0);
            done();
        });
    });

    it('should handle backpressure correctly', (done) => {
        const slowWritable = new Writable({
            write(chunk, encoding, callback) {
                setTimeout(callback, 50);
            }
        });

        let pauseDetected = false;
        let resumeDetected = false;

        bufferManager.on('pause', () => {
            pauseDetected = true;
        });

        bufferManager.on('resume', () => {
            resumeDetected = true;
            if (pauseDetected && resumeDetected) {
                done();
            }
        });

        bufferManager.pipe(slowWritable);

        // Write enough data to trigger backpressure
        for (let i = 0; i < 20; i++) {
            bufferManager.write(Buffer.alloc(100 * 1024)); // 100KB chunks
        }
    });

    it('should maintain buffer metrics', (done) => {
        const data = Buffer.alloc(512 * 1024); // 512KB

        bufferManager.write(data, () => {
            const metrics = bufferManager.getMetrics();
            expect(metrics.maxBufferUsage).to.be.above(0);
            expect(metrics.bufferUtilization).to.be.above(0);
            expect(metrics.overflowEvents).to.equal(0);
            done();
        });
    });

    it('should flush buffer on end', (done) => {
        const data = ['chunk1', 'chunk2', 'chunk3'];
        const output = [];

        const writable = new Writable({
            objectMode: true,
            write(chunk, encoding, callback) {
                output.push(chunk);
                callback();
            }
        });

        bufferManager
            .pipe(writable)
            .on('finish', () => {
                expect(output).to.deep.equal(data);
                expect(bufferManager.getMetrics().currentBufferSize).to.equal(0);
                done();
            });

        data.forEach(chunk => bufferManager.write(chunk));
        bufferManager.end();
    });
});
</antArtifact>

<antArtifact identifier="stream-connector-test" type="application/vnd.ant.code" language="javascript" title="StreamConnector.spec.js">
import { expect } from 'chai';
import StreamProcessor from '../../src/processors/base/StreamProcessor.js';
import Processor from '../../src/processors/base/Processor.js';
import StreamConnector from '../../src/engine/StreamConnector.js';

describe('StreamConnector', () => {
    let connector;
    let fromProcessor;
    let toProcessor;

    beforeEach(() => {
        connector = new StreamConnector('from', 'to');
    });

    it('should connect streaming processors', (done) => {
        fromProcessor = new StreamProcessor({});
        toProcessor = new StreamProcessor({});

        const processors = {
            from: fromProcessor,
            to: toProcessor
        };

        connector.connect(processors);

        toProcessor.on('data', (data) => {
            expect(data.content).to.equal('test');
            done();
        });

        fromProcessor.write({ content: 'test' });
    });

    it('should connect event-based processors', (done) => {
        fromProcessor = new Processor({});
        toProcessor = new Processor({});

        const processors = {
            from: fromProcessor,
            to: toProcessor
        };

        connector.connect(processors);

        toProcessor.on('message', (message) => {
            expect(message.content).to.equal('test');
            done();
        });

        fromProcessor.emit('message', { content: 'test' });
    });

    it('should handle mixed mode connections', (done) => {
        fromProcessor = new StreamProcessor({});
        toProcessor = new Processor({});

        const processors = {
            from: fromProcessor,
            to: toProcessor
        };

        connector.connect(processors);

        toProcessor.on('message', (message) => {
            expect(message.content).to.equal('test');
            done();
        });

        fromProcessor.write({ content: 'test' });
    });

    it('should throw error for invalid processors', () => {
        expect(() => connector.connect({
            from: null,
            to: new Processor({})
        })).to.throw('Invalid processor connection');
    });
});
</antArtifact>

These tests verify:

1. Basic streaming functionality
2. Performance monitoring
3. Buffer management
4. Error handling
5. Mixed mode operation
6. Resource cleanup

Would you like me to:

q1: Add more specific test cases for edge conditions?

q2: Create integration tests for the complete pipeline?

q3: Add performance benchmarking tests?

q4: Create mock objects for testing specific scenarios?

---

* **sourceFile** : /home/danny/github-danny/hyperdata/docs/chat-archives/data-2025-01-25-12-45-58/conversations.json
* **appName** : claude-json-converter
* **appPath** : claude-json-converter
* **subtask** : [undefined]
* **rootDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter
* **dataDir** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **targetPath** : /home/danny/github-danny/transmissions/src/applications/claude-json-converter/data
* **tags** : ccc10.ccc20.ccc30.ccc40.ccc50
* **done** : [undefined]
* **meta** : {
  "conv_uuid": "7352ddcc-bebe-4ba3-b94b-48f2e20746ab",
  "conv_name": "Extending Event-Driven Processors to Support Streaming",
  "updated_at": "2024-11-30T22:29:56.938448Z"
}
* **filepath** : /home/danny/github-danny/hyperdata/docs/postcraft/content-raw/chat-archives/md/7352/2024-11-30_90b.md