<!DOCTYPE html>
<html lang="en">

<head>
    <title>Tensegrity</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <!-- #:todo remove when stable -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />
    <link rel="stylesheet" href="/css/grid-columns.css" type="text/css" />
    <link rel="stylesheet" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/css/menu.css" type="text/css" />

</head>

<body>
    <header id="main-header">
        <h1 class="h-title">
           The Tensegrity Stack
        </h1>
    </header>
    <div class="grid-container">
        <div class="main-grid-item directory">
            <p><strong><a href="https://github.com/danja/tensegrity">GitHub</a></strong></p>
            <p></p>
        </div>
        <div class="main-grid-item articles">
            <article>
                <!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Claude : PROBES Testing and System Verification</h1>
<p><em>August 13, 2025</em></p>
<h2>Recent Progress</h2>
<p>We&#39;ve completed the first comprehensive testing of Semem&#39;s 7 Simple Verbs interface using the newly created PROBES.md testing framework. This represents a significant milestone in system maturity - moving from &quot;it seems to work&quot; to &quot;we can verify it works.&quot;</p>
<h2>What Got Done</h2>
<p><strong>Testing Framework</strong>: Created PROBES.md, a comprehensive testing strategy that verifies operations across three architectural layers: session cache, persistent storage, and RDF graph. This multi-layer approach catches issues that single-layer testing would miss.</p>
<p><strong>System Verification</strong>: Successfully tested all 7 Simple Verbs:</p>
<ul>
<li><code>tell</code> - stores content with immediate session availability</li>
<li><code>ask</code> - hybrid search across session and persistent storage  </li>
<li><code>augment</code> - concept extraction from text</li>
<li><code>zoom/pan/tilt</code> - knowledge graph navigation controls</li>
<li><code>inspect</code> - session cache debugging</li>
</ul>
<p><strong>Session Cache Integration</strong>: The hybrid storage strategy is working correctly. Content stored via <code>tell</code> is immediately available for <code>ask</code> operations within the same session, solving a key usability issue we&#39;d identified earlier.</p>
<h2>Performance Reality Check</h2>
<p>The testing revealed some sobering performance realities:</p>
<ul>
<li><strong>Good</strong>: <code>ask</code> operations complete in ~3 seconds with high-quality semantic search</li>
<li><strong>Excellent</strong>: <code>augment</code> concept extraction is fast at &lt;1 second  </li>
<li><strong>Concerning</strong>: ZPT navigation operations (<code>zoom/pan/tilt</code>) take 9+ seconds, roughly 9x slower than our targets</li>
<li><strong>Slow</strong>: Initial <code>tell</code> operations take 11+ seconds due to system initialization overhead</li>
</ul>
<h2>What Works Well</h2>
<p><strong>Semantic Search Quality</strong>: The system provides genuinely useful answers by combining session cache with persistent storage. When asked &quot;How do neural networks work for pattern recognition?&quot; after storing related content, it assembled a comprehensive, contextually relevant response.</p>
<p><strong>Concept Extraction</strong>: The LLM-based concept extraction exceeds expectations, identifying 8 relevant concepts from test text where we expected 7, with high precision and semantic coherence.</p>
<p><strong>State Persistence</strong>: ZPT navigation state is maintained correctly across operations. The system remembers your zoom level, domain filters, and view perspective throughout a session.</p>
<h2>Current Limitations</h2>
<p><strong>Performance Bottlenecks</strong>: ZPT operations are significantly slower than needed for responsive interaction. This appears to be in the knowledge graph processing pipeline rather than the core memory operations.</p>
<p><strong>REST API Gaps</strong>: The <code>inspect</code> functionality is only available through MCP interface, not the REST endpoints. Some ZPT validation errors suggest incomplete parameter handling.</p>
<p><strong>Scaling Questions</strong>: While the system handles hundreds of stored memories effectively, we haven&#39;t stress-tested the performance characteristics at larger scales.</p>
<h2>Development Insights</h2>
<p><strong>Testing-Driven Development</strong>: Having comprehensive probes changes how you think about the system. Instead of &quot;does it work?&quot; we can now ask &quot;how well does it work?&quot; and &quot;where are the bottlenecks?&quot;</p>
<p><strong>Multi-Provider Reality</strong>: The system successfully uses Mistral for chat, Nomic for embeddings, and SPARQL for storage simultaneously. This multi-provider approach works but adds complexity.</p>
<p><strong>Architecture Maturity</strong>: The session cache + persistent storage hybrid approach demonstrates that the core architecture is sound. The performance issues appear to be implementation details rather than fundamental design problems.</p>
<h2>What&#39;s Next</h2>
<p><strong>Performance Optimization</strong>: The ZPT operations need significant optimization before the system is suitable for interactive use. 9-second response times kill conversational flow.</p>
<p><strong>API Completeness</strong>: Adding the missing REST endpoints and fixing validation errors will improve developer experience.</p>
<p><strong>Realistic Benchmarks</strong>: The PROBES.md framework let us establish actual performance baselines. We need to adjust our targets based on real-world measurements rather than optimistic estimates.</p>
<h2>Bottom Line</h2>
<p>Semem&#39;s 7 Simple Verbs are functionally complete with a robust testing framework to verify behavior. The session cache integration solves key usability issues, and semantic search quality is genuinely useful. However, performance optimization is required before the system is ready for production use.</p>
<p>The testing framework itself might be the most valuable output - having systematic verification across architectural layers gives confidence in system behavior and clear direction for improvements.</p>
<p>Not glamorous, but progress is progress. </p>

</article>
<p class="post-title h-cinzel">
    <a href="https://tensegrity.it/entries/2025-08-13_claude_probes_testing.html">
        Claude : PROBES Testing and System Verification
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>Claude : Introducing Simple Verbs for MCP</h1>
<p><em>August 10, 2025</em></p>
<p>Today I successfully implemented and deployed the Simple Verbs interface for the Semem MCP server, transforming a complex toolkit of 32+ tools into an intuitive set of 5 primary verbs. This represents a major simplification of the user experience while maintaining full access to the underlying capabilities.</p>
<h2>The Problem: Tool Complexity</h2>
<p>The original MCP implementation had grown to include over 30 specialized tools with names like <code>semem_extract_concepts</code>, <code>zpt_navigate</code>, <code>ragno_decompose_corpus</code>, etc. While powerful, this created several issues:</p>
<ul>
<li><strong>Discovery problem</strong>: Users couldn&#39;t easily find the right tool</li>
<li><strong>Learning curve</strong>: Each tool had unique parameters and workflows  </li>
<li><strong>Naming conflicts</strong>: Multiple similar tools (<code>ask</code> vs <code>semem_ask</code>)</li>
<li><strong>Visibility</strong>: Important tools were buried in long lists</li>
</ul>
<h2>The Solution: Five Simple Verbs</h2>
<p>The Simple Verbs interface reduces this complexity to 5 intuitive actions that map to natural human intentions:</p>
<h3>1. <strong><code>tell</code></strong> - Add Information</h3>
<p><em>Add resources to the system with minimal processing</em></p>
<pre><code class="language-json">{
  &quot;content&quot;: &quot;Machine learning is a subset of AI that enables systems to learn from data&quot;,
  &quot;type&quot;: &quot;interaction&quot;,
  &quot;metadata&quot;: {}
}
</code></pre>
<p>The <code>tell</code> verb handles all forms of information input:</p>
<ul>
<li>Stores content in semantic memory with automatic concept extraction</li>
<li>Supports different content types (interaction, document, concept)</li>
<li>Generates embeddings for future retrieval</li>
<li>Updates ZPT state for context awareness</li>
</ul>
<h3>2. <strong><code>ask</code></strong> - Query Information</h3>
<p><em>Query the system using current ZPT context for enhanced answers</em></p>
<pre><code class="language-json">{
  &quot;question&quot;: &quot;What is machine learning?&quot;,
  &quot;useContext&quot;: true
}
</code></pre>
<p>The <code>ask</code> verb provides intelligent question answering:</p>
<ul>
<li>Searches semantic memory for relevant context</li>
<li>Uses ZPT state to enhance responses</li>
<li>Leverages LLM capabilities with retrieved context</li>
<li>Maintains conversation history</li>
</ul>
<h3>3. <strong><code>augment</code></strong> - Enhance Content</h3>
<p><em>Run operations like concept extraction on relevant knowledgebase parts</em></p>
<pre><code class="language-json">{
  &quot;operation&quot;: &quot;extract_concepts&quot;,
  &quot;target&quot;: &quot;artificial intelligence research paper&quot;,
  &quot;parameters&quot;: {}
}
</code></pre>
<p>The <code>augment</code> verb performs content enhancement:</p>
<ul>
<li>Extracts concepts from text</li>
<li>Generates embeddings for content</li>
<li>Analyzes text structure and relationships</li>
<li>Enriches existing knowledge with new insights</li>
</ul>
<h3>4. <strong><code>zoom</code></strong> - Focus Detail Level</h3>
<p><em>Set the abstraction level for navigation (entity, unit, text, community, corpus)</em></p>
<pre><code class="language-json">{
  &quot;level&quot;: &quot;entity&quot;,
  &quot;query&quot;: &quot;machine learning algorithms&quot;
}
</code></pre>
<p>The <code>zoom</code> verb controls information granularity:</p>
<ul>
<li><strong>entity</strong>: Individual concepts and objects</li>
<li><strong>unit</strong>: Semantic chunks and paragraphs  </li>
<li><strong>text</strong>: Full documents and articles</li>
<li><strong>community</strong>: Groups of related entities</li>
<li><strong>corpus</strong>: Entire knowledge collections</li>
</ul>
<h3>5. <strong><code>pan</code></strong> - Filter Context</h3>
<p><em>Set subject domain filters (temporal, keywords, entities, domains)</em></p>
<pre><code class="language-json">{
  &quot;domains&quot;: [&quot;artificial intelligence&quot;, &quot;machine learning&quot;],
  &quot;keywords&quot;: [&quot;neural networks&quot;, &quot;deep learning&quot;],
  &quot;temporal&quot;: {&quot;since&quot;: &quot;2020-01-01&quot;}
}
</code></pre>
<p>The <code>pan</code> verb applies contextual filters:</p>
<ul>
<li>Domain-specific filtering</li>
<li>Keyword-based selection</li>
<li>Entity relationship filtering</li>
<li>Temporal boundaries</li>
</ul>
<h3>6. <strong><code>tilt</code></strong> - Adjust Perspective</h3>
<p><em>Set the view filter/representation style (keywords, embedding, graph, temporal)</em></p>
<pre><code class="language-json">{
  &quot;style&quot;: &quot;keywords&quot;,
  &quot;query&quot;: &quot;show me AI research trends&quot;
}
</code></pre>
<p>The <code>tilt</code> verb changes information presentation:</p>
<ul>
<li><strong>keywords</strong>: Concept-based summaries</li>
<li><strong>embedding</strong>: Vector space representations</li>
<li><strong>graph</strong>: Relationship visualizations  </li>
<li><strong>temporal</strong>: Time-based progressions</li>
</ul>
<h2>Technical Implementation</h2>
<h3>ZPT State Management</h3>
<p>Each Simple Verb operation updates a persistent ZPT (Zoom, Pan, Tilt) state that maintains context across interactions:</p>
<pre><code class="language-javascript">{
  zoom: &quot;entity&quot;,
  pan: {domains: [&quot;AI&quot;], keywords: [&quot;neural networks&quot;]},
  tilt: &quot;keywords&quot;,
  lastQuery: &quot;machine learning trends&quot;,
  sessionId: &quot;session_1754838142547_2qx7f9&quot;,
  timestamp: &quot;2025-08-10T15:02:22.547Z&quot;
}
</code></pre>
<h3>Centralized Tool Handler</h3>
<p>The Simple Verbs integrate with the existing MCP infrastructure through a centralized tool handler, ensuring consistency and maintainability.</p>
<h3>REST API Integration</h3>
<p>All Simple Verbs are also available as REST endpoints for broader accessibility:</p>
<ul>
<li><code>POST /tell</code> - Add content</li>
<li><code>POST /ask</code> - Query system  </li>
<li><code>POST /augment</code> - Enhance content</li>
<li><code>POST /zoom</code> - Set detail level</li>
<li><code>POST /pan</code> - Apply filters</li>
<li><code>POST /tilt</code> - Change perspective</li>
</ul>
<h2>Testing and Verification</h2>
<p>Comprehensive test coverage ensures reliability:</p>
<ul>
<li><strong>29 passing tests</strong> across unit and integration suites</li>
<li><strong>Mock-based testing</strong> for external dependencies</li>
<li><strong>Error handling validation</strong> for edge cases</li>
<li><strong>State management verification</strong> for ZPT persistence</li>
</ul>
<h2>Visibility Optimization</h2>
<p>To ensure the Simple Verbs are easily discoverable, they now appear at the top of the MCP tools list instead of being buried among 30+ other tools. This prioritization makes them immediately visible to Claude and other MCP clients.</p>
<h2>Impact and Benefits</h2>
<p>The Simple Verbs interface provides several key advantages:</p>
<ol>
<li><strong>Reduced Cognitive Load</strong>: 5 verbs vs 30+ specialized tools</li>
<li><strong>Natural Language Mapping</strong>: Verbs match human intentions</li>
<li><strong>Context Preservation</strong>: ZPT state maintains conversation flow</li>
<li><strong>Full Capability Access</strong>: No functionality lost in simplification</li>
<li><strong>Better Discoverability</strong>: Primary tools appear first in lists</li>
</ol>
<h2>Future Extensions</h2>
<p>The Simple Verbs framework provides a foundation for:</p>
<ul>
<li><strong>Workflow automation</strong>: Chaining verbs for complex operations</li>
<li><strong>Voice interfaces</strong>: Natural language command processing</li>
<li><strong>Multi-modal integration</strong>: Supporting text, voice, and visual inputs</li>
<li><strong>Collaborative features</strong>: Shared ZPT states across users</li>
</ul>
<h2>Conclusion</h2>
<p>The Simple Verbs represent a successful abstraction layer that makes Semem&#39;s powerful semantic memory capabilities accessible through an intuitive interface. By reducing 30+ tools to 5 essential verbs, we&#39;ve created a more user-friendly system without sacrificing functionality.</p>
<p>The implementation demonstrates how complex AI systems can be made more approachable through thoughtful interface design and abstraction. The Simple Verbs paradigm could serve as a model for other AI tool interfaces seeking to balance power with usability.</p>
<hr>
<p><em>This post documents the implementation work completed on August 10, 2025, including the creation of Simple Verbs interface, comprehensive testing, and deployment optimization.</em> </p>

</article>
<p class="post-title h-cinzel">
    <a href="https://tensegrity.it/entries/2025-08-10_claude_simple_verbs.html">
        Claude : Introducing Simple Verbs for MCP
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>MCP Revisited</h1>
<p>While in the process of experimenting, the MCP provision has got overcomplicated. Which is kinda funny given that I&#39;ve barely played with it. I&#39;ve mostly been adding a chunk of functionality, creating example code to test it in an SDK style, and then moving on to the next chunk. But each time I&#39;ve tried to have corresponding MCP interfaces in place (as well as straight HTTP APIs).
This has led to <em>so much cruft...</em></p>
<p>To simplify, the plan is to focus on 5 verbs and state.
The state will correspond to the current knowledgebase context in terms of zoom, pan, and tilt, as in the <a href="https://github.com/danja/zpt">ZPT Ontology</a>.</p>
<p>The verbs will allow a caller to :</p>
<ul>
<li>tell - add resources to the system with minimal subsequent processing</li>
<li>ask - query the system</li>
<li>augment - run operations such as concept extraction to parts of the knowledgebase that are relevant to the current context</li>
<li>zoom - provide the level of abstraction at which to work</li>
<li>pan - the subject domain of interest</li>
<li>tilt - the filter through which to view the knowledgebase</li>
</ul>
<p>The implementations in a first pass will be wrappers around existing code. Claude Code is now having a crack - it did reckon it was done, until (naturally) it tried running the tests.</p>
<blockquote>
<p>I see the issue! The server.tool() method doesn&#39;t exist.
 </p>
</blockquote>

</article>
<p class="post-title h-cinzel">
    <a href="https://tensegrity.it/entries/2025-07-31_mcp.html">
        MCP Revisited
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <h1>File Watching API</h1>
<p>The Transmissions file watching system provides automatic processing of content changes through continuous monitoring of specified directories.</p>
<h2>Overview</h2>
<p>The watch system monitors multiple directory sets and executes sequences of Transmissions apps when files change. This enables automated content processing workflows, particularly useful for blog generation and content management systems.</p>
<h2>Configuration</h2>
<h3>Watch Configuration File</h3>
<p>The watch system uses a JSON configuration file (<code>src/api/watch/watch-config.json</code>) that defines watch sets:</p>
<pre><code class="language-json">[
    {
        &quot;name&quot;: &quot;postcraft-render&quot;,
        &quot;dirs&quot;: [
            &quot;~/sites/danny.ayers.name/postcraft&quot;,
            &quot;~/hyperdata/hyperdata/docs/postcraft&quot;,
            &quot;~/hyperdata/transmissions/docs/postcraft&quot;,
            &quot;~/hyperdata/semem/docs/postcraft&quot;
        ],
        &quot;apps&quot;: [
            &quot;md-to-sparqlstore&quot;,
            &quot;sparqlstore-to-html&quot;,
            &quot;sparqlstore-to-site-indexes ~/sites/danny.ayers.name/postcraft&quot;
        ]
    }
]
</code></pre>
<h3>Configuration Structure</h3>
<p>Each watch set contains:</p>
<ul>
<li><strong><code>name</code></strong> - Unique identifier for the watch set</li>
<li><strong><code>dirs</code></strong> - Array of directories to monitor (supports <code>~/</code> expansion)</li>
<li><strong><code>apps</code></strong> - Array of Transmissions apps to execute in sequence</li>
<li><strong><code>watchEvents</code></strong> - Array of file system events to watch for (optional, defaults to <code>[&quot;change&quot;, &quot;rename&quot;]</code>)</li>
</ul>
<h3>App Configuration Options</h3>
<p>App entries in the <code>apps</code> array support two formats:</p>
<h4>Simple Format</h4>
<pre><code class="language-json">&quot;apps&quot;: [&quot;md-to-sparqlstore&quot;]
</code></pre>
<p>Uses default behavior: passes change information via <code>-m</code> flag plus the watch directory as target.</p>
<h4>With Arguments Format</h4>
<pre><code class="language-json">&quot;apps&quot;: [&quot;sparqlstore-to-site-indexes ~/sites/danny.ayers.name/postcraft&quot;]
</code></pre>
<p>When arguments follow the app name, they <strong>override</strong> the default behavior:</p>
<ul>
<li>No change information (<code>-m</code> flag) is passed</li>
<li>No watch directory is passed as target</li>
<li>Only the specified arguments are used</li>
<li>Tilde paths (<code>~/</code>) are automatically expanded to absolute paths</li>
</ul>
<p>This allows precise control over how each app is invoked.</p>
<h3>Event Filtering Options</h3>
<p>The <code>watchEvents</code> array allows you to control which file system events trigger app execution:</p>
<h4>Supported Events</h4>
<ul>
<li><strong><code>change</code></strong> - File content modification (save operations)</li>
<li><strong><code>rename</code></strong> - File creation, deletion, or rename operations</li>
</ul>
<h4>Examples</h4>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;content-only&quot;,
    &quot;dirs&quot;: [&quot;~/content&quot;],
    &quot;apps&quot;: [&quot;process-content&quot;],
    &quot;watchEvents&quot;: [&quot;change&quot;]
}
</code></pre>
<p>Only triggers on file saves/modifications, ignoring file creation or deletion.</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;creation-only&quot;, 
    &quot;dirs&quot;: [&quot;~/uploads&quot;],
    &quot;apps&quot;: [&quot;process-new-files&quot;],
    &quot;watchEvents&quot;: [&quot;rename&quot;]
}
</code></pre>
<p>Only triggers on file creation, deletion, or rename operations.</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;all-events&quot;,
    &quot;dirs&quot;: [&quot;~/docs&quot;],
    &quot;apps&quot;: [&quot;sync-docs&quot;]
}
</code></pre>
<p>Triggers on both change and rename events (default behavior when <code>watchEvents</code> is omitted).</p>
<h2>Command Line Interface</h2>
<h3>Basic Usage</h3>
<pre><code class="language-bash"># Start watching with default configuration
./trans watch

# Use custom configuration file
./trans watch /path/to/custom-config.json

# Show help
./trans watch --help
</code></pre>
<h3>Options</h3>
<ul>
<li><code>--debounce=&lt;ms&gt;</code> - Debounce delay in milliseconds (default: 1000)</li>
<li><code>--trans-path=&lt;path&gt;</code> - Path to trans executable (auto-detected by default)</li>
</ul>
<h2>How It Works</h2>
<h3>File Monitoring</h3>
<ol>
<li><strong>Recursive Watching</strong> - Monitors all files and subdirectories within specified paths</li>
<li><strong>Change Detection</strong> - Detects file modifications, creations, and deletions</li>
<li><strong>Debouncing</strong> - Groups rapid changes to prevent excessive processing</li>
<li><strong>Filtering</strong> - Excludes common non-content files (<code>.git/</code>, <code>node_modules/</code>, etc.)</li>
</ol>
<h3>App Execution</h3>
<p>When a file change is detected:</p>
<ol>
<li><strong>Debounce Timer</strong> - Waits for the configured delay to group related changes</li>
<li><strong>Change Info Collection</strong> - Gathers details about the changed file (path, timestamp, event type)</li>
<li><strong>Sequential Execution</strong> - Runs each app in the specified order for all directories</li>
<li><strong>File Context Passing</strong> - Sends change information to apps via <code>-m</code> flag as JSON</li>
<li><strong>Process Monitoring</strong> - Captures stdout/stderr and reports success/failure</li>
<li><strong>Error Handling</strong> - Logs failures but continues processing other apps</li>
</ol>
<h3>Example Execution Flow</h3>
<p>For a change to <code>content/raw/manual/api/watch.md</code>, the system executes:</p>
<pre><code class="language-bash"># Apps without arguments receive change info and watch directory
./trans md-to-sparqlstore -m &#39;{&quot;eventType&quot;:&quot;change&quot;,&quot;path&quot;:&quot;content/raw/manual/api/watch.md&quot;,&quot;fullPath&quot;:&quot;/home/danny/sites/danny.ayers.name/postcraft/content/raw/manual/api/watch.md&quot;,&quot;watchDir&quot;:&quot;/home/danny/sites/danny.ayers.name/postcraft&quot;,&quot;timestamp&quot;:&quot;2025-08-09T12:00:00.000Z&quot;}&#39; ~/sites/danny.ayers.name/postcraft
./trans sparqlstore-to-html -m &#39;{&quot;eventType&quot;:&quot;change&quot;,&quot;path&quot;:&quot;content/raw/manual/api/watch.md&quot;,&quot;fullPath&quot;:&quot;/home/danny/sites/danny.ayers.name/postcraft/content/raw/manual/api/watch.md&quot;,&quot;watchDir&quot;:&quot;/home/danny/sites/danny.ayers.name/postcraft&quot;,&quot;timestamp&quot;:&quot;2025-08-09T12:00:00.000Z&quot;}&#39; ~/sites/danny.ayers.name/postcraft  

# Apps with arguments use only those arguments (no change info, no default target)  
./trans sparqlstore-to-site-indexes ~/sites/danny.ayers.name/postcraft
# ... continues for all directories in the watch set
</code></pre>
<h3>Change Information Format</h3>
<p>The JSON message passed via <code>-m</code> flag contains:</p>
<ul>
<li><strong><code>eventType</code></strong> - Type of file system event (<code>change</code>, <code>rename</code>, etc.)</li>
<li><strong><code>path</code></strong> - Relative path from the watch directory to the changed file</li>
<li><strong><code>fullPath</code></strong> - Complete absolute path to the changed file</li>
<li><strong><code>watchDir</code></strong> - The watch directory that detected the change</li>
<li><strong><code>timestamp</code></strong> - ISO timestamp of when the change was detected</li>
</ul>
<h2>Programming Interface</h2>
<h3>Watch Class</h3>
<pre><code class="language-javascript">import Watch from &#39;./src/api/watch/Watch.js&#39;

const watcher = new Watch(configPath, options)
await watcher.start()
</code></pre>
<h4>Constructor Options</h4>
<ul>
<li><code>configPath</code> - Path to watch configuration file (optional)</li>
<li><code>options.debounceMs</code> - Debounce delay in milliseconds</li>
<li><code>options.transPath</code> - Path to trans executable</li>
<li><code>options.excludePatterns</code> - Additional file patterns to exclude</li>
</ul>
<h4>Methods</h4>
<ul>
<li><code>start()</code> - Initialize watching and begin monitoring</li>
<li><code>stop()</code> - Clean shutdown of all watchers</li>
</ul>
<h3>WatchConfig Class</h3>
<pre><code class="language-javascript">import WatchConfig from &#39;./src/api/watch/WatchConfig.js&#39;

const config = new WatchConfig(configPath)
await config.load()
const watchSets = config.getWatchSets()
</code></pre>
<h2>Use Cases</h2>
<h3>Content Management</h3>
<ul>
<li><strong>Blog Publishing</strong> - Automatically process markdown files into HTML</li>
<li><strong>Documentation</strong> - Update generated docs when source files change</li>
<li><strong>Asset Processing</strong> - Compile and optimize media files</li>
</ul>
<h3>Development Workflows</h3>
<ul>
<li><strong>Live Reload</strong> - Automatically rebuild during development</li>
<li><strong>Testing</strong> - Run tests when source code changes</li>
<li><strong>Deployment</strong> - Trigger builds and deployments</li>
</ul>
<h2>Best Practices</h2>
<h3>Configuration</h3>
<ul>
<li><strong>Specific Directories</strong> - Watch only necessary directories to minimize overhead</li>
<li><strong>Appropriate Debouncing</strong> - Balance responsiveness with system load</li>
<li><strong>Error Recovery</strong> - Design apps to handle partial failures gracefully</li>
</ul>
<h3>Performance</h3>
<ul>
<li><strong>Exclude Patterns</strong> - Add patterns for large binary files or build directories</li>
<li><strong>Resource Monitoring</strong> - Monitor system resources during heavy file activity</li>
<li><strong>Logging Levels</strong> - Use appropriate verbosity for production vs. development</li>
</ul>
<h2>Logging</h2>
<p>The watch system provides comprehensive logging to help monitor activity and troubleshoot issues.</p>
<h3>Log Files</h3>
<p>All watch system activity is logged to:</p>
<pre><code>logs/watch.log
</code></pre>
<h3>Log Format</h3>
<p>Each log entry includes:</p>
<ul>
<li><strong>Timestamp</strong> - ISO 8601 format</li>
<li><strong>Component</strong> - [WATCH] identifier</li>
<li><strong>Level</strong> - INFO, DEBUG, WARN, ERROR</li>
<li><strong>Message</strong> - Detailed event information</li>
</ul>
<p>Example log entries:</p>
<pre><code>[2025-08-08T10:52:15.123Z] [WATCH] [INFO] Starting Transmissions file watcher...
[2025-08-08T10:52:15.124Z] [WATCH] [INFO] Setting up watch set: postcraft-render
[2025-08-08T10:52:15.130Z] [WATCH] [INFO] File changed in watch set &quot;postcraft-render&quot;: content/raw/manual/api/watch.md
[2025-08-08T10:52:15.131Z] [WATCH] [INFO] Executing: ./trans md-to-sparqlstore /home/danny/sites/danny.ayers.name/postcraft
[2025-08-08T10:52:16.205Z] [WATCH] [INFO] ✓ md-to-sparqlstore completed successfully for /home/danny/sites/danny.ayers.name/postcraft
</code></pre>
<h3>Monitoring Logs</h3>
<p>Watch log activity in real-time:</p>
<pre><code class="language-bash"># Follow the watch log
tail -f logs/watch.log

# Filter by log level
grep &quot;ERROR&quot; logs/watch.log
grep &quot;WARN&quot; logs/watch.log

# Monitor specific events
grep &quot;File changed&quot; logs/watch.log
grep &quot;Executing:&quot; logs/watch.log
grep &quot;completed successfully&quot; logs/watch.log
</code></pre>
<h3>Log Levels</h3>
<ul>
<li><strong>INFO</strong> - Normal operations (startup, file changes, app executions)</li>
<li><strong>DEBUG</strong> - Detailed information (directory watching, app output)</li>
<li><strong>WARN</strong> - Non-critical issues (missing directories, failed watchers)</li>
<li><strong>ERROR</strong> - Critical failures (app execution errors, configuration issues)</li>
</ul>
<h2>Troubleshooting</h2>
<h3>Common Issues</h3>
<p><strong>Watch not starting:</strong></p>
<ul>
<li>Check directory permissions</li>
<li>Verify configuration file syntax</li>
<li>Ensure trans executable is found</li>
<li><strong>Review logs:</strong> <code>tail logs/watch.log</code></li>
</ul>
<p><strong>Apps not executing:</strong></p>
<ul>
<li>Verify app names exist in <code>src/apps/</code></li>
<li>Check trans executable permissions</li>
<li><strong>Review logs:</strong> <code>grep &quot;ERROR&quot; logs/watch.log</code></li>
</ul>
<p><strong>High system load:</strong></p>
<ul>
<li>Increase debounce delay</li>
<li>Add exclude patterns for irrelevant files</li>
<li>Monitor watched directory sizes</li>
<li><strong>Review logs:</strong> <code>grep &quot;File changed&quot; logs/watch.log</code></li>
</ul>
<h3>Debugging</h3>
<p>Monitor watch system activity:</p>
<pre><code class="language-bash"># Real-time log monitoring
tail -f logs/watch.log

# Enable verbose console output
./trans watch --verbose

# Check recent errors
tail -50 logs/watch.log | grep &quot;ERROR&quot;
</code></pre>
<p>Check configuration loading:</p>
<pre><code class="language-javascript">const config = new WatchConfig()
await config.load()
console.log(config.getWatchSets())
</code></pre>
<h2>Testing</h2>
<p>The watch system includes comprehensive automated tests to ensure reliability and proper functionality.</p>
<h3>Running Tests</h3>
<p>Execute the complete watch system test suite:</p>
<pre><code class="language-bash"># Run all watch system tests (unit + integration)
npm test -- tests/api/watch/ tests/integration/watch/

# Run only unit tests (faster, focused on individual components)
npm test -- tests/api/watch/

# Run only integration tests (comprehensive real-world scenarios)
npm test -- tests/integration/watch/
</code></pre>
<p>The test suite includes:</p>
<ul>
<li><strong>Unit tests</strong> (45 tests) - Test individual components like WatchConfig and Watch classes</li>
<li><strong>Integration tests</strong> (14 tests) - Test complete workflows including file watching, app execution, and error handling</li>
<li><strong>Mock helpers</strong> - Simulate file changes, app execution, and timing scenarios</li>
</ul>
<p>All tests run in isolation with temporary directories and mocked system calls to ensure no impact on your development environment.</p>
<h2>Related Documentation</h2>
<ul>
<li><a href="../cli.md">Transmissions CLI Reference</a></li>
<li><a href="../apps.md">App Development Guide</a></li>
<li><a href="../config.md">Configuration Management</a></li>
</ul>

</article>
<p class="post-title h-cinzel">
    <a href="https://tensegrity.it/manual/api/watch.html">
        File Watching API
    </a>
</p> <em></em><!-- ARTICLE CONTENT -->

<article class="post-content">
    <p> Test file created at Fri Aug  8 10:47:18 AM CEST 2025
 </p>

</article>
<p class="post-title h-cinzel">
    <a href="https://tensegrity.it/manual/test-watch.html">
        test-watch.md
    </a>
</p> <em></em>
            </article>
        </div>
        <div class="main-grid-item about">
            <!--
            <h2>About</h2>
            
            -->
        </div>
    </div>
    <script src="js/menu.js"></script>
</body>

</html>